<!DOCTYPE html><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="theme-color" content="#375EAB"/>

  <title>sign - Go Documentation Server</title>

<link type="text/css" rel="stylesheet" href="../../../../../../../lib/godoc/style.css"/>

<script>window.initFuncs = [];</script>
<script src="../../../../../../../lib/godoc/jquery.js" defer=""></script>



<script>var goVersion = "go1.17";</script>
<script src="../../../../../../../lib/godoc/godocs.js" defer=""></script>
</head>
<body>

<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="http://localhost:6060/pkg/">Go Documentation Server</a></div>
<div class="top-heading" id="heading-narrow"><a href="http://localhost:6060/pkg/">GoDoc</a></div>
<a href="index.html#" id="menu-button"><span id="menu-button-arrow">▽</span></a>
<form method="GET" action="http://localhost:6060/search">
<div id="menu">

<span class="search-box"><input type="search" id="search" name="q" placeholder="Search" aria-label="Search" required=""/><button type="submit"><span><!-- magnifying glass: --><svg width="24" height="24" viewBox="0 0 24 24"><title>submit search</title><path d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path><path d="M0 0h24v24H0z" fill="none"></path></svg></span></button></span>
</div>
</form>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Package sign
    <span class="text-muted"></span>
  </h1>







<div id="nav"></div>


<!--
	Copyright 2009 The Go Authors. All rights reserved.
	Use of this source code is governed by a BSD-style
	license that can be found in the LICENSE file.
-->
<!--
	Note: Static (i.e., not template-generated) href and id
	attributes start with "pkg-" to make it impossible for
	them to conflict with generated attributes (some of which
	correspond to Go identifiers).
-->

	<script>
	document.ANALYSIS_DATA = null;
	document.CALLGRAPH = null;
	</script>

	
		
		<div id="short-nav">
			<dl>
			<dd><code>import &#34;github.com/aws/aws-sdk-go/service/cloudfront/sign&#34;</code></dd>
			</dl>
			<dl>
			<dd><a href="index.html#pkg-overview" class="overviewLink">Overview</a></dd>
			<dd><a href="index.html#pkg-index" class="indexLink">Index</a></dd>
			
				<dd><a href="index.html#pkg-examples" class="examplesLink">Examples</a></dd>
			
			
			</dl>
		</div>
		<!-- The package's Name is printed as title by the top-level template -->
		<div id="pkg-overview" class="toggleVisible">
			<div class="collapsed">
				<h2 class="toggleButton" title="Click to show Overview section">Overview ▹</h2>
			</div>
			<div class="expanded">
				<h2 class="toggleButton" title="Click to hide Overview section">Overview ▾</h2>
				<p>
Package sign provides utilities to generate signed URLs for Amazon CloudFront.
</p>
<p>
More information about signed URLs and their structure can be found at:
<a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-canned-policy.html">http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-canned-policy.html</a>
</p>
<p>
To sign a URL create a URLSigner with your private key and credential pair key ID.
Once you have a URLSigner instance you can call Sign or SignWithPolicy to
sign the URLs.
</p>
<p>
Example:
</p>
<pre>// Sign URL to be valid for 1 hour from now.
signer := sign.NewURLSigner(keyID, privKey)
signedURL, err := signer.Sign(rawURL, time.Now().Add(1*time.Hour))
if err != nil {
    log.Fatalf(&#34;Failed to sign url, err: %s\n&#34;, err.Error())
}
</pre>

				
			</div>
		</div>

		<div id="pkg-index" class="toggleVisible">
		<div class="collapsed">
			<h2 class="toggleButton" title="Click to show Index section">Index ▹</h2>
		</div>
		<div class="expanded">
			<h2 class="toggleButton" title="Click to hide Index section">Index ▾</h2>

		<!-- Table of contents for API; must be named manual-nav to turn off auto nav. -->
			<div id="manual-nav">
			<dl>
			
				<dd><a href="index.html#pkg-constants">Constants</a></dd>
			
			
			
				
				<dd><a href="index.html#CreateResource">func CreateResource(scheme, u string) (string, error)</a></dd>
			
				
				<dd><a href="index.html#LoadEncryptedPEMPrivKey">func LoadEncryptedPEMPrivKey(reader io.Reader, password []byte) (*rsa.PrivateKey, error)</a></dd>
			
				
				<dd><a href="index.html#LoadPEMPrivKey">func LoadPEMPrivKey(reader io.Reader) (*rsa.PrivateKey, error)</a></dd>
			
				
				<dd><a href="index.html#LoadPEMPrivKeyFile">func LoadPEMPrivKeyFile(name string) (*rsa.PrivateKey, error)</a></dd>
			
			
				
				<dd><a href="index.html#AWSEpochTime">type AWSEpochTime</a></dd>
				
					
					<dd>    <a href="index.html#NewAWSEpochTime">func NewAWSEpochTime(t time.Time) *AWSEpochTime</a></dd>
				
				
					
					<dd>    <a href="index.html#AWSEpochTime.MarshalJSON">func (t AWSEpochTime) MarshalJSON() ([]byte, error)</a></dd>
				
					
					<dd>    <a href="index.html#AWSEpochTime.UnmarshalJSON">func (t *AWSEpochTime) UnmarshalJSON(data []byte) error</a></dd>
				
			
				
				<dd><a href="index.html#Condition">type Condition</a></dd>
				
				
			
				
				<dd><a href="index.html#CookieOptions">type CookieOptions</a></dd>
				
				
			
				
				<dd><a href="index.html#CookieSigner">type CookieSigner</a></dd>
				
					
					<dd>    <a href="index.html#NewCookieSigner">func NewCookieSigner(keyID string, privKey *rsa.PrivateKey, opts ...func(*CookieOptions)) *CookieSigner</a></dd>
				
				
					
					<dd>    <a href="index.html#CookieSigner.Sign">func (s CookieSigner) Sign(u string, expires time.Time, opts ...func(*CookieOptions)) ([]*http.Cookie, error)</a></dd>
				
					
					<dd>    <a href="index.html#CookieSigner.SignWithPolicy">func (s CookieSigner) SignWithPolicy(p *Policy, opts ...func(*CookieOptions)) ([]*http.Cookie, error)</a></dd>
				
			
				
				<dd><a href="index.html#IPAddress">type IPAddress</a></dd>
				
				
			
				
				<dd><a href="index.html#Policy">type Policy</a></dd>
				
					
					<dd>    <a href="index.html#NewCannedPolicy">func NewCannedPolicy(resource string, expires time.Time) *Policy</a></dd>
				
				
					
					<dd>    <a href="index.html#Policy.Sign">func (p *Policy) Sign(privKey *rsa.PrivateKey) (b64Signature, b64Policy []byte, err error)</a></dd>
				
					
					<dd>    <a href="index.html#Policy.Validate">func (p *Policy) Validate() error</a></dd>
				
			
				
				<dd><a href="index.html#Statement">type Statement</a></dd>
				
				
			
				
				<dd><a href="index.html#URLSigner">type URLSigner</a></dd>
				
					
					<dd>    <a href="index.html#NewURLSigner">func NewURLSigner(keyID string, privKey *rsa.PrivateKey) *URLSigner</a></dd>
				
				
					
					<dd>    <a href="index.html#URLSigner.Sign">func (s URLSigner) Sign(url string, expires time.Time) (string, error)</a></dd>
				
					
					<dd>    <a href="index.html#URLSigner.SignWithPolicy">func (s URLSigner) SignWithPolicy(url string, p *Policy) (string, error)</a></dd>
				
			
			
			</dl>
			</div><!-- #manual-nav -->

		
		<div id="pkg-examples">
			<h3>Examples</h3>
			<div class="js-expandAll expandAll collapsed">(Expand All)</div>
			<dl>
			
			<dd><a class="exampleLink" href="index.html#example_CookieOptions">CookieOptions</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_CookieSigner_Sign">CookieSigner.Sign</a></dd>
			
			<dd><a class="exampleLink" href="index.html#example_CookieSigner_SignWithPolicy">CookieSigner.SignWithPolicy</a></dd>
			
			</dl>
		</div>
		

		
			<h3>Package files</h3>
			<p>
			<span style="font-size:90%">
			
				<a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go">policy.go</a>
			
				<a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy_json_1_7.go">policy_json_1_7.go</a>
			
				<a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/privkey.go">privkey.go</a>
			
				<a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/randomreader.go">randomreader.go</a>
			
				<a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_cookie.go">sign_cookie.go</a>
			
				<a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_url.go">sign_url.go</a>
			
			</span>
			</p>
		
		</div><!-- .expanded -->
		</div><!-- #pkg-index -->

		

		
			<h2 id="pkg-constants">Constants</h2>
			
				
				<pre>const (
    <span class="comment">// CookiePolicyName name of the policy cookie</span>
    <span id="CookiePolicyName">CookiePolicyName</span> = &#34;CloudFront-Policy&#34;
    <span class="comment">// CookieSignatureName name of the signature cookie</span>
    <span id="CookieSignatureName">CookieSignatureName</span> = &#34;CloudFront-Signature&#34;
    <span class="comment">// CookieKeyIDName name of the signing Key ID cookie</span>
    <span id="CookieKeyIDName">CookieKeyIDName</span> = &#34;CloudFront-Key-Pair-Id&#34;
)</pre>
			
		
		
		
			
			
			<h2 id="CreateResource">func <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=4233:4286#L130">CreateResource</a>
				<a class="permalink" href="index.html#CreateResource">¶</a>
				
				
			</h2>
			<pre>func CreateResource(scheme, u <a href="../../../../../../builtin/index.html#string">string</a>) (<a href="../../../../../../builtin/index.html#string">string</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>
CreateResource constructs, validates, and returns a resource URL string. An
error will be returned if unable to create the resource string.
</p>

			
			

		
			
			
			<h2 id="LoadEncryptedPEMPrivKey">func <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/privkey.go?s=936:1024#L29">LoadEncryptedPEMPrivKey</a>
				<a class="permalink" href="index.html#LoadEncryptedPEMPrivKey">¶</a>
				
				
			</h2>
			<pre>func LoadEncryptedPEMPrivKey(reader <a href="../../../../../../io/index.html">io</a>.<a href="../../../../../../io/index.html#Reader">Reader</a>, password []<a href="../../../../../../builtin/index.html#byte">byte</a>) (*<a href="../../../../../../crypto/rsa/index.html">rsa</a>.<a href="../../../../../../crypto/rsa/index.html#PrivateKey">PrivateKey</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>
LoadEncryptedPEMPrivKey decrypts the PEM encoded private key using the
password provided returning a RSA private key. If the PEM data is invalid,
or unable to decrypt an error will be returned.
</p>

			
			

		
			
			
			<h2 id="LoadPEMPrivKey">func <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/privkey.go?s=548:610#L17">LoadPEMPrivKey</a>
				<a class="permalink" href="index.html#LoadPEMPrivKey">¶</a>
				
				
			</h2>
			<pre>func LoadPEMPrivKey(reader <a href="../../../../../../io/index.html">io</a>.<a href="../../../../../../io/index.html#Reader">Reader</a>) (*<a href="../../../../../../crypto/rsa/index.html">rsa</a>.<a href="../../../../../../crypto/rsa/index.html#PrivateKey">PrivateKey</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>
LoadPEMPrivKey reads a PEM encoded RSA private key from the io.Reader.
A new RSA private key will be returned if no error.
</p>

			
			

		
			
			
			<h2 id="LoadPEMPrivKeyFile">func <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/privkey.go?s=236:297#L5">LoadPEMPrivKeyFile</a>
				<a class="permalink" href="index.html#LoadPEMPrivKeyFile">¶</a>
				
				
			</h2>
			<pre>func LoadPEMPrivKeyFile(name <a href="../../../../../../builtin/index.html#string">string</a>) (*<a href="../../../../../../crypto/rsa/index.html">rsa</a>.<a href="../../../../../../crypto/rsa/index.html#PrivateKey">PrivateKey</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
			<p>
LoadPEMPrivKeyFile reads a PEM encoded RSA private key from the file name.
A new RSA private key will be returned if no error.
</p>

			
			

		
		
			
			
			<h2 id="AWSEpochTime">type <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=290:329#L11">AWSEpochTime</a>
				<a class="permalink" href="index.html#AWSEpochTime">¶</a>
				
				
			</h2>
			<p>
An AWSEpochTime wraps a time value providing JSON serialization needed for
AWS Policy epoch time fields.
</p>

			<pre>type AWSEpochTime struct {
    <a href="../../../../../../time/index.html">time</a>.<a href="../../../../../../time/index.html#Time">Time</a>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewAWSEpochTime">func <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=416:463#L16">NewAWSEpochTime</a>
					<a class="permalink" href="index.html#NewAWSEpochTime">¶</a>
					
					
				</h3>
				<pre>func NewAWSEpochTime(t <a href="../../../../../../time/index.html">time</a>.<a href="../../../../../../time/index.html#Time">Time</a>) *<a href="index.html#AWSEpochTime">AWSEpochTime</a></pre>
				<p>
NewAWSEpochTime returns a new AWSEpochTime pointer wrapping the Go time provided.
</p>

				
				
			

			
				
				<h3 id="AWSEpochTime.MarshalJSON">func (AWSEpochTime) <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=562:613#L21">MarshalJSON</a>
					<a class="permalink" href="index.html#AWSEpochTime.MarshalJSON">¶</a>
					
					
				</h3>
				<pre>func (t <a href="index.html#AWSEpochTime">AWSEpochTime</a>) MarshalJSON() ([]<a href="../../../../../../builtin/index.html#byte">byte</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
				<p>
MarshalJSON serializes the epoch time as AWS Profile epoch time.
</p>

				
				
				
			
				
				<h3 id="AWSEpochTime.UnmarshalJSON">func (*AWSEpochTime) <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=746:801#L26">UnmarshalJSON</a>
					<a class="permalink" href="index.html#AWSEpochTime.UnmarshalJSON">¶</a>
					
					
				</h3>
				<pre>func (t *<a href="index.html#AWSEpochTime">AWSEpochTime</a>) UnmarshalJSON(data []<a href="../../../../../../builtin/index.html#byte">byte</a>) <a href="../../../../../../builtin/index.html#error">error</a></pre>
				<p>
UnmarshalJSON unserializes AWS Profile epoch time.
</p>

				
				
				
			
		
			
			
			<h2 id="Condition">type <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=1225:1709#L44">Condition</a>
				<a class="permalink" href="index.html#Condition">¶</a>
				
				
			</h2>
			<p>
A Condition defines the restrictions for how a signed URL can be used.
</p>

			<pre>type Condition struct {
    <span class="comment">// Optional IP address mask the signed URL must be requested from.</span>
<span id="Condition.IPAddress"></span>    IPAddress *<a href="index.html#IPAddress">IPAddress</a> `json:&#34;IpAddress,omitempty&#34;`

    <span class="comment">// Optional date that the signed URL cannot be used until. It is invalid</span>
    <span class="comment">// to make requests with the signed URL prior to this date.</span>
<span id="Condition.DateGreaterThan"></span>    DateGreaterThan *<a href="index.html#AWSEpochTime">AWSEpochTime</a> `json:&#34;,omitempty&#34;`

    <span class="comment">// Required date that the signed URL will expire. A DateLessThan is required</span>
    <span class="comment">// sign cloud front URLs</span>
<span id="Condition.DateLessThan"></span>    DateLessThan *<a href="index.html#AWSEpochTime">AWSEpochTime</a> `json:&#34;,omitempty&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="CookieOptions">type <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_cookie.go?s=466:538#L12">CookieOptions</a>
				<a class="permalink" href="index.html#CookieOptions">¶</a>
				
				
			</h2>
			<p>
A CookieOptions optional additional options that can be applied to the signed
cookies.
</p>

			<pre>type CookieOptions struct {
<span id="CookieOptions.Path"></span>    Path   <a href="../../../../../../builtin/index.html#string">string</a>
<span id="CookieOptions.Domain"></span>    Domain <a href="../../../../../../builtin/index.html#string">string</a>
<span id="CookieOptions.Secure"></span>    Secure <a href="../../../../../../builtin/index.html#bool">bool</a>
}
</pre>

			

			

			<div id="example_CookieOptions" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code">privKey := mock.RSAPrivateKey

<span class="comment">// Create the CookieSigner with options set. These options can be set</span>
<span class="comment">// directly with cookieSigner.Opts. These values can be overridden on</span>
<span class="comment">// individual Sign and SignWithProfile calls.</span>
cookieSigner := NewCookieSigner(&#34;keyID&#34;, privKey, func(o *CookieOptions) {
    <span class="comment">//provide an optional struct fields to specify other options</span>
    o.Path = &#34;/&#34;

    <span class="comment">// http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/CNAMEs.html</span>
    o.Domain = &#34;.cNameAssociatedWithMyDistribution.com&#34;

    <span class="comment">// Make sure your app/site can handle https payloads, otherwise</span>
    <span class="comment">// set this to false.</span>
    o.Secure = true
})

<span class="comment">// Use the signer to sign the URL</span>
cookies, err := cookieSigner.Sign(&#34;http*://*&#34;, testSignTime.Add(30*time.Minute), func(o *CookieOptions) {
    o.Path = &#34;/mypath/&#34;
})
if err != nil {
    fmt.Println(&#34;failed to sign cookies with policy,&#34;, err)
    return
}

printExampleCookies(cookies)
<span class="comment"></span></pre>
			
			<p>Output:</p>
			<pre class="output">Cookies:
CloudFront-Policy: eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cCo6Ly8qIiwiQ29uZGl0aW9uIjp7IkRhdGVMZXNzVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxMjU3ODk1ODAwfX19XX0_, /mypath/, .cNameAssociatedWithMyDistribution.com, true
CloudFront-Signature: DBXEcU6NoyAelecgEcr6mE1IHCqqlHdGwAC2X1dYn0QOLZ8Ar~oehlMub~hEh~UEMijR15ii-yUYf-3ML0b1SwWkh4rTa-SFURWDVuu~vW3cQzRZ4wQrgDR3DGJINrtGtEsDSzA6zdwtZsfvc1W9IRPn9rnVmwDdUurSrcp9M7CdcjkEw9Au~gULX7aUuW87DI5GI7jLo6emmBB1p4V~xAv8rDqOyxdhBzWKDTvl6ErIXnzHitgMclNZrkn-m27BhTQsJOs2R~gT2VrQw-IWX6NMD8r0TDH4DE2HQ8N7jZ0nf8gezbyFk-OhD1P9FUNb1PlwcZWfXtfgHQmM-BmrSQ__, /mypath/, .cNameAssociatedWithMyDistribution.com, true
CloudFront-Key-Pair-Id: keyID, /mypath/, .cNameAssociatedWithMyDistribution.com, true
</pre>
			
		
	</div>
</div>

			
			

			

			
		
			
			
			<h2 id="CookieSigner">type <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_cookie.go?s=1624:1714#L45">CookieSigner</a>
				<a class="permalink" href="index.html#CookieSigner">¶</a>
				
				
			</h2>
			<p>
A CookieSigner provides signing utilities to sign Cookies for Amazon CloudFront
resources. Using a private key and Credential Key Pair key ID the CookieSigner
only needs to be created once per Credential Key Pair key ID and private key.
</p>
<p>
More information about signed Cookies and their structure can be found at:
<a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-setting-signed-cookie-custom-policy.html">http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-setting-signed-cookie-custom-policy.html</a>
</p>
<p>
To sign a Cookie, create a CookieSigner with your private key and credential
pair key ID. Once you have a CookieSigner instance you can call Sign or
SignWithPolicy to sign the URLs.
</p>
<p>
The signer is safe to use concurrently, but the optional cookies options
are not safe to modify concurrently.
</p>

			<pre>type CookieSigner struct {
<span id="CookieSigner.Opts"></span>    Opts <a href="index.html#CookieOptions">CookieOptions</a>
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewCookieSigner">func <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_cookie.go?s=1844:1947#L54">NewCookieSigner</a>
					<a class="permalink" href="index.html#NewCookieSigner">¶</a>
					
					
				</h3>
				<pre>func NewCookieSigner(keyID <a href="../../../../../../builtin/index.html#string">string</a>, privKey *<a href="../../../../../../crypto/rsa/index.html">rsa</a>.<a href="../../../../../../crypto/rsa/index.html#PrivateKey">PrivateKey</a>, opts ...func(*<a href="index.html#CookieOptions">CookieOptions</a>)) *<a href="index.html#CookieSigner">CookieSigner</a></pre>
				<p>
NewCookieSigner constructs and returns a new CookieSigner to be used to for
signing Amazon CloudFront URL resources with.
</p>

				
				
			

			
				
				<h3 id="CookieSigner.Sign">func (CookieSigner) <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_cookie.go?s=3456:3565#L105">Sign</a>
					<a class="permalink" href="index.html#CookieSigner.Sign">¶</a>
					
					
				</h3>
				<pre>func (s <a href="index.html#CookieSigner">CookieSigner</a>) Sign(u <a href="../../../../../../builtin/index.html#string">string</a>, expires <a href="../../../../../../time/index.html">time</a>.<a href="../../../../../../time/index.html#Time">Time</a>, opts ...func(*<a href="index.html#CookieOptions">CookieOptions</a>)) ([]*<a href="../../../../../../net/http/index.html">http</a>.<a href="../../../../../../net/http/index.html#Cookie">Cookie</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Sign returns the cookies needed to allow user agents to make arbetrary
requests to cloudfront for the resource(s) defined by the policy.
</p>
<p>
Sign will create a CloudFront policy with only a resource and condition of
DateLessThan equal to the expires time provided.
</p>
<p>
The returned slice cookies should all be added to the Client&#39;s cookies or
server&#39;s response.
</p>
<p>
Example:
</p>
<pre>s := sign.NewCookieSigner(keyID, privKey)

// Get Signed cookies for a resource that will expire in 1 hour
cookies, err := s.Sign(&#34;*&#34;, time.Now().Add(1 * time.Hour))
if err != nil {
    fmt.Println(&#34;failed to create signed cookies&#34;, err)
    return
}

// Or get Signed cookies for a resource that will expire in 1 hour
// and set path and domain of cookies
cookies, err := s.Sign(&#34;*&#34;, time.Now().Add(1 * time.Hour), func(o *sign.CookieOptions) {
    o.Path = &#34;/&#34;
    o.Domain = &#34;.example.com&#34;
})
if err != nil {
    fmt.Println(&#34;failed to create signed cookies&#34;, err)
    return
}

// Server Response via http.ResponseWriter
for _, c := range cookies {
    http.SetCookie(w, c)
}

// Client request via the cookie jar
if client.CookieJar != nil {
    for _, c := range cookies {
       client.Cookie(w, c)
    }
}
</pre>

				
				<div id="example_CookieSigner_Sign" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Load your private key so it can be used by the CookieSigner</span>
<span class="comment">// To load private key from file use `sign.LoadPEMPrivKeyFile`.</span>
privKey := mock.RSAPrivateKey

cookieSigner := NewCookieSigner(&#34;keyID&#34;, privKey)

<span class="comment">// Use the signer to sign the URL</span>
cookies, err := cookieSigner.Sign(&#34;http://example.com/somepath/*&#34;, testSignTime.Add(30*time.Minute))
if err != nil {
    fmt.Println(&#34;failed to sign cookies with policy,&#34;, err)
    return
}

printExampleCookies(cookies)
<span class="comment"></span></pre>
			
			<p>Output:</p>
			<pre class="output">Cookies:
CloudFront-Policy: eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cDovL2V4YW1wbGUuY29tL3NvbWVwYXRoLyoiLCJDb25kaXRpb24iOnsiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjEyNTc4OTU4MDB9fX1dfQ__, , , false
CloudFront-Signature: Gx67J8t1VanOFWN84BQlpN064aGCicJv916esnPr9Rdb2RKEzl7VoDOsh9Uez7SY5blWATkN5F3xNicTpOupdN-ywrTf5zCTLz5RmvLrIyEDS3Y1knTGoWvp6nnIb9FOuI1rSyBaJ8VKuNVQGmvqzXGXsnipgSBPjpkL6Ja3dBXeKIbUeaLKQBZrtMWv9nS5VyG4nOP-CRcTgQ5DA3-h~WP2ZzhONb6yoYXeOSvBu8HBl0IZI27InLpxiKlkWUchNncnkZ32Md0CwLLrA4wxFl0fYsxxg6Us2XBYRGmudugJHgkkopem9Cc4eOiDGMABcJGAuZprVXT0WuOBYJngTA__, , , false
CloudFront-Key-Pair-Id: keyID, , , false
</pre>
			
		
	</div>
</div>

				
			
				
				<h3 id="CookieSigner.SignWithPolicy">func (CookieSigner) <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_cookie.go?s=6498:6599#L192">SignWithPolicy</a>
					<a class="permalink" href="index.html#CookieSigner.SignWithPolicy">¶</a>
					
					
				</h3>
				<pre>func (s <a href="index.html#CookieSigner">CookieSigner</a>) SignWithPolicy(p *<a href="index.html#Policy">Policy</a>, opts ...func(*<a href="index.html#CookieOptions">CookieOptions</a>)) ([]*<a href="../../../../../../net/http/index.html">http</a>.<a href="../../../../../../net/http/index.html#Cookie">Cookie</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
				<p>
SignWithPolicy returns the cookies needed to allow user agents to make
arbetrairy requets to cloudfront for the resource(s) defined by the policy.
</p>
<p>
The returned slice cookies should all be added to the Client&#39;s cookies or
server&#39;s response.
</p>
<p>
Example:
</p>
<pre>s := sign.NewCookieSigner(keyID, privKey)

policy := &amp;sign.Policy{
    Statements: []sign.Statement{
        {
            // Read the provided documentation on how to set this
            // correctly, you&#39;ll probably want to use wildcards.
            Resource: rawCloudFrontURL,
            Condition: sign.Condition{
                // Optional IP source address range
                IPAddress: &amp;sign.IPAddress{SourceIP: &#34;192.0.2.0/24&#34;},
                // Optional date URL is not valid until
                DateGreaterThan: &amp;sign.AWSEpochTime{time.Now().Add(30 * time.Minute)},
                // Required date the URL will expire after
                DateLessThan: &amp;sign.AWSEpochTime{time.Now().Add(1 * time.Hour)},
            },
        },
    },
}

// Get Signed cookies for a resource that will expire in 1 hour
cookies, err := s.SignWithPolicy(policy)
if err != nil {
    fmt.Println(&#34;failed to create signed cookies&#34;, err)
    return
}

// Or get Signed cookies for a resource that will expire in 1 hour
// and set path and domain of cookies
cookies, err := s.SignWithPolicy(policy, func(o *sign.CookieOptions) {
    o.Path = &#34;/&#34;
    o.Domain = &#34;.example.com&#34;
})
if err != nil {
    fmt.Println(&#34;failed to create signed cookies&#34;, err)
    return
}

// Server Response via http.ResponseWriter
for _, c := range cookies {
    http.SetCookie(w, c)
}

// Client request via the cookie jar
if client.CookieJar != nil {
    for _, c := range cookies {
       client.Cookie(w, c)
    }
}
</pre>

				
				<div id="example_CookieSigner_SignWithPolicy" class="toggle">
	<div class="collapsed">
		<p class="exampleHeading toggleButton">▹ <span class="text">Example</span></p>
	</div>
	<div class="expanded">
		<p class="exampleHeading toggleButton">▾ <span class="text">Example</span></p>
		
		
		
			<p>Code:</p>
			<pre class="code"><span class="comment">// Sign cookie to be valid for 30 minutes from now, expires one hour</span>
<span class="comment">// from now, and restricted to the 192.0.2.0/24 IP address range.</span>
<span class="comment">// http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-setting-signed-cookie-custom-policy.html</span>
p := &amp;Policy{
    <span class="comment">// Only a single policy statement can be used with CloudFront</span>
    <span class="comment">// cookie signatures.</span>
    Statements: []Statement{{
        <span class="comment">// Read the provided documentation on how to set this correctly,</span>
        <span class="comment">// you&#39;ll probably want to use wildcards</span>
        Resource: &#34;http://sub.cloudfront.com&#34;,
        Condition: Condition{
            <span class="comment">// Optional IP source address range</span>
            IPAddress: &amp;IPAddress{SourceIP: &#34;192.0.2.0/24&#34;},
            <span class="comment">// Optional date URL is not valid until</span>
            DateGreaterThan: &amp;AWSEpochTime{testSignTime.Add(30 * time.Minute)},
            <span class="comment">// Required date the URL will expire after</span>
            DateLessThan: &amp;AWSEpochTime{testSignTime.Add(1 * time.Hour)},
        },
    },
    },
}

<span class="comment">// Load your private key so it can be used by the CookieSigner</span>
<span class="comment">// To load private key from file use `sign.LoadPEMPrivKeyFile`.</span>
privKey := mock.RSAPrivateKey

<span class="comment">// Key ID that represents the key pair associated with the private key</span>
keyID := &#34;privateKeyID&#34;

<span class="comment">// Set credentials to the CookieSigner.</span>
cookieSigner := NewCookieSigner(keyID, privKey)

<span class="comment">// Avoid adding an Expire or MaxAge. See provided AWS Documentation for</span>
<span class="comment">// more info.</span>
cookies, err := cookieSigner.SignWithPolicy(p)
if err != nil {
    fmt.Println(&#34;failed to sign cookies with policy,&#34;, err)
    return
}

printExampleCookies(cookies)
<span class="comment"></span></pre>
			
			<p>Output:</p>
			<pre class="output">Cookies:
CloudFront-Policy: eyJTdGF0ZW1lbnQiOlt7IlJlc291cmNlIjoiaHR0cDovL3N1Yi5jbG91ZGZyb250LmNvbSIsIkNvbmRpdGlvbiI6eyJJcEFkZHJlc3MiOnsiQVdTOlNvdXJjZUlwIjoiMTkyLjAuMi4wLzI0In0sIkRhdGVHcmVhdGVyVGhhbiI6eyJBV1M6RXBvY2hUaW1lIjoxMjU3ODk1ODAwfSwiRGF0ZUxlc3NUaGFuIjp7IkFXUzpFcG9jaFRpbWUiOjEyNTc4OTc2MDB9fX1dfQ__, , , false
CloudFront-Signature: Ixn4bF1LLrLcB8XG-t5bZbIB0vfwSF2s4gkef~PcNBdx73MVvZD3v8DZ5GzcqNrybMiqdYJY5KqK6vTsf5JXDgwFFz-h98wdsbV-izcuonPdzMHp4Ay4qyXM6Ed5jB9dUWYGwMkA6rsWXpftfX8xmk4tG1LwFuJV6nAsx4cfpuKwo4vU2Hyr2-fkA7MZG8AHkpDdVUnjm1q-Re9HdG0nCq-2lnBAdOchBpJt37narOj-Zg6cbx~6rzQLVQd8XIv-Bn7VTc1tkBAJVtGOHb0q~PLzSRmtNGYTnpL0z~gp3tq8lhZc2HuvJW5-tZaYP9yufeIzk5bqsT6DT4iDuclKKw__, , , false
CloudFront-Key-Pair-Id: privateKeyID, , , false
</pre>
			
		
	</div>
</div>

				
			
		
			
			
			<h2 id="IPAddress">type <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=1085:1149#L39">IPAddress</a>
				<a class="permalink" href="index.html#IPAddress">¶</a>
				
				
			</h2>
			<p>
An IPAddress wraps an IPAddress source IP providing JSON serialization information
</p>

			<pre>type IPAddress struct {
<span id="IPAddress.SourceIP"></span>    SourceIP <a href="../../../../../../builtin/index.html#string">string</a> `json:&#34;AWS:SourceIp&#34;`
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="Policy">type <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=2251:2419#L70">Policy</a>
				<a class="permalink" href="index.html#Policy">¶</a>
				
				
			</h2>
			<p>
A Policy defines the resources that a signed will be signed for.
</p>
<p>
See the following page for more information on how policies are constructed.
<a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html#private-content-custom-policy-statement">http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html#private-content-custom-policy-statement</a>
</p>

			<pre>type Policy struct {
    <span class="comment">// List of resource and condition statements.</span>
    <span class="comment">// Signed URLs should only provide a single statement.</span>
<span id="Policy.Statements"></span>    Statements []<a href="index.html#Statement">Statement</a> `json:&#34;Statement&#34;`
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewCannedPolicy">func <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=5298:5362#L160">NewCannedPolicy</a>
					<a class="permalink" href="index.html#NewCannedPolicy">¶</a>
					
					
				</h3>
				<pre>func NewCannedPolicy(resource <a href="../../../../../../builtin/index.html#string">string</a>, expires <a href="../../../../../../time/index.html">time</a>.<a href="../../../../../../time/index.html#Time">Time</a>) *<a href="index.html#Policy">Policy</a></pre>
				<p>
NewCannedPolicy returns a new Canned Policy constructed using the resource
and expires time. This can be used to generate the basic model for a Policy
that can be then augmented with additional conditions.
</p>
<p>
See the following page for more information on how policies are constructed.
<a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html#private-content-custom-policy-statement">http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-creating-signed-url-custom-policy.html#private-content-custom-policy-statement</a>
</p>

				
				
			

			
				
				<h3 id="Policy.Sign">func (*Policy) <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=2852:2942#L85">Sign</a>
					<a class="permalink" href="index.html#Policy.Sign">¶</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Policy">Policy</a>) Sign(privKey *<a href="../../../../../../crypto/rsa/index.html">rsa</a>.<a href="../../../../../../crypto/rsa/index.html#PrivateKey">PrivateKey</a>) (b64Signature, b64Policy []<a href="../../../../../../builtin/index.html#byte">byte</a>, err <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Sign will sign a policy using an RSA private key. It will return a base 64
encoded signature and policy if no error is encountered.
</p>
<p>
The signature and policy should be added to the signed URL following the
guidelines in:
<a href="http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-signed-urls.html">http://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/private-content-signed-urls.html</a>
</p>

				
				
				
			
				
				<h3 id="Policy.Validate">func (*Policy) <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=3489:3522#L109">Validate</a>
					<a class="permalink" href="index.html#Policy.Validate">¶</a>
					
					
				</h3>
				<pre>func (p *<a href="index.html#Policy">Policy</a>) Validate() <a href="../../../../../../builtin/index.html#error">error</a></pre>
				<p>
Validate verifies that the policy is valid and usable, and returns an
error if there is a problem.
</p>

				
				
				
			
		
			
			
			<h2 id="Statement">type <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/policy.go?s=1770:1934#L58">Statement</a>
				<a class="permalink" href="index.html#Statement">¶</a>
				
				
			</h2>
			<p>
A Statement is a collection of conditions for resources
</p>

			<pre>type Statement struct {
    <span class="comment">// The Web or RTMP resource the URL will be signed for</span>
<span id="Statement.Resource"></span>    Resource <a href="../../../../../../builtin/index.html#string">string</a>

    <span class="comment">// The set of conditions for this resource</span>
<span id="Statement.Condition"></span>    Condition <a href="index.html#Condition">Condition</a>
}
</pre>

			

			

			
			
			

			

			
		
			
			
			<h2 id="URLSigner">type <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_url.go?s=1125:1191#L24">URLSigner</a>
				<a class="permalink" href="index.html#URLSigner">¶</a>
				
				
			</h2>
			<p>
An URLSigner provides URL signing utilities to sign URLs for Amazon CloudFront
resources. Using a private key and Credential Key Pair key ID the URLSigner
only needs to be created once per Credential Key Pair key ID and private key.
</p>
<p>
The signer is safe to use concurrently.
</p>

			<pre>type URLSigner struct {
    <span class="comment">// contains filtered or unexported fields</span>
}
</pre>

			

			

			
			
			

			
				
				<h3 id="NewURLSigner">func <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_url.go?s=1315:1382#L31">NewURLSigner</a>
					<a class="permalink" href="index.html#NewURLSigner">¶</a>
					
					
				</h3>
				<pre>func NewURLSigner(keyID <a href="../../../../../../builtin/index.html#string">string</a>, privKey *<a href="../../../../../../crypto/rsa/index.html">rsa</a>.<a href="../../../../../../crypto/rsa/index.html#PrivateKey">PrivateKey</a>) *<a href="index.html#URLSigner">URLSigner</a></pre>
				<p>
NewURLSigner constructs and returns a new URLSigner to be used to for signing
Amazon CloudFront URL resources with.
</p>

				
				
			

			
				
				<h3 id="URLSigner.Sign">func (URLSigner) <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_url.go?s=2133:2203#L54">Sign</a>
					<a class="permalink" href="index.html#URLSigner.Sign">¶</a>
					
					
				</h3>
				<pre>func (s <a href="index.html#URLSigner">URLSigner</a>) Sign(url <a href="../../../../../../builtin/index.html#string">string</a>, expires <a href="../../../../../../time/index.html">time</a>.<a href="../../../../../../time/index.html#Time">Time</a>) (<a href="../../../../../../builtin/index.html#string">string</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
				<p>
Sign will sign a single URL to expire at the time of expires sign using the
Amazon CloudFront default Canned Policy. The URL will be signed with the
private key and Credential Key Pair Key ID previously provided to URLSigner.
</p>
<p>
This is the default method of signing Amazon CloudFront URLs. If extra policy
conditions are need other than URL expiry use SignWithPolicy instead.
</p>
<p>
Example:
</p>
<pre>// Sign URL to be valid for 1 hour from now.
signer := sign.NewURLSigner(keyID, privKey)
signedURL, err := signer.Sign(rawURL, time.Now().Add(1*time.Hour))
if err != nil {
    log.Fatalf(&#34;Failed to sign url, err: %s\n&#34;, err.Error())
}
</pre>

				
				
				
			
				
				<h3 id="URLSigner.SignWithPolicy">func (URLSigner) <a href="http://localhost:6060/src/github.com/aws/aws-sdk-go/service/cloudfront/sign/sign_url.go?s=4127:4199#L104">SignWithPolicy</a>
					<a class="permalink" href="index.html#URLSigner.SignWithPolicy">¶</a>
					
					
				</h3>
				<pre>func (s <a href="index.html#URLSigner">URLSigner</a>) SignWithPolicy(url <a href="../../../../../../builtin/index.html#string">string</a>, p *<a href="index.html#Policy">Policy</a>) (<a href="../../../../../../builtin/index.html#string">string</a>, <a href="../../../../../../builtin/index.html#error">error</a>)</pre>
				<p>
SignWithPolicy will sign a URL with the Policy provided.  The URL will be
signed with the private key and Credential Key Pair Key ID previously provided to URLSigner.
</p>
<p>
Use this signing method if you are looking to sign a URL with more than just
the URL&#39;s expiry time, or reusing Policies between multiple URL signings.
If only the expiry time is needed you can use Sign and provide just the
URL&#39;s expiry time. A minimum of at least one policy statement is required for a signed URL.
</p>
<p>
Note: It is not safe to use Polices between multiple signers concurrently
</p>
<p>
Example:
</p>
<pre>// Sign URL to be valid for 30 minutes from now, expires one hour from now, and
// restricted to the 192.0.2.0/24 IP address range.
policy := &amp;sign.Policy{
    Statements: []sign.Statement{
        {
            Resource: rawURL,
            Condition: sign.Condition{
                // Optional IP source address range
                IPAddress: &amp;sign.IPAddress{SourceIP: &#34;192.0.2.0/24&#34;},
                // Optional date URL is not valid until
                DateGreaterThan: &amp;sign.AWSEpochTime{time.Now().Add(30 * time.Minute)},
                // Required date the URL will expire after
                DateLessThan: &amp;sign.AWSEpochTime{time.Now().Add(1 * time.Hour)},
            },
        },
    },
}

signer := sign.NewURLSigner(keyID, privKey)
signedURL, err := signer.SignWithPolicy(rawURL, policy)
if err != nil {
    log.Fatalf(&#34;Failed to sign url, err: %s\n&#34;, err.Error())
}
</pre>

				
				
				
			
		
	

	







<div id="footer">
Build version go1.17.<br/>
Except as <a href="https://developers.google.com/site-policies#restrictions">noted</a>,
the content of this page is licensed under the
Creative Commons Attribution 3.0 License,
and code is licensed under a <a href="http://localhost:6060/LICENSE">BSD license</a>.<br/>
<a href="https://golang.org/doc/tos.html">Terms of Service</a> |
<a href="https://www.google.com/intl/en/policies/privacy/">Privacy Policy</a>
</div>

</div><!-- .container -->
</div><!-- #page -->


</body></html>